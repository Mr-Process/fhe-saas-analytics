"""
Server-side evaluator for FHE-based SaaS analytics service.

This module receives serialized ciphertexts from clients, deserializes them
using a provided context, performs homomorphic computation on the encrypted
values, and returns serialized ciphertext results. It illustrates how to
structure server-side logic for privacy-preserving analytics.

The functions here are simple examples; a production system would need
additional functionality, such as secure key exchange, batching, more complex
analytics, and parameter tuning.  The evaluator must never have access to
the client's secret key.
"""

from typing import List

try:
    from Pyfhel import Pyfhel, PyCtxt
except ImportError:
    Pyfhel = None  # type: ignore
    PyCtxt = None  # type: ignore


class FHEEvaluator:
    """
    Evaluator for performing encrypted computations. The evaluator requires
    access to the encryption context but never the secret key.  The context
    parameters and public keys must be provided by the client.
    """

    def __init__(self, context_params: dict) -> None:
        """
        Initialise the evaluator with encryption parameters provided by the client.

        :param context_params: dictionary containing contextGen parameters.
        """
        if Pyfhel is None:
            raise ImportError(
                "Pyfhel is required for FHEEvaluator. Install it via pip (e.g. pip install pyfhel)."
            )
        self.he = Pyfhel()
        # The context generation replicates the client's parameters.  This ensures
        # that ciphertexts created by the client can be processed on the server.
        self.he.contextGen(**context_params)
        # In a real implementation, the public, relinearization, and rotation
        # keys would be imported at this point using he.publicKey, he.relinKey
        # and he.rotateKey.  These keys are generated by the client and sent
        # along with the encrypted data.

    def deserialize_ciphertexts(self, data: List[bytes]) -> List['PyCtxt']:
        """
        Deserialize a list of ciphertext byte strings into Pyfhel ciphertexts.

        :param data: list of byte strings.
        :return: list of ciphertext objects.
        """
        return [self.he.ciphertext_from_bytes(b) for b in data]

    def serialize_ciphertexts(self, ciphertexts: List['PyCtxt']) -> List[bytes]:
        """Serialize ciphertexts into byte strings for returning to client."""
        return [ctxt.to_bytes() for ctxt in ciphertexts]

    def sum_encrypted(self, ciphertexts: List['PyCtxt']) -> 'PyCtxt':
        """
        Homomorphically sum a list of ciphertexts.

        :param ciphertexts: list of ciphertext objects.
        :return: ciphertext representing the sum of all inputs.
        """
        if not ciphertexts:
            raise ValueError("ciphertexts list cannot be empty")
        result = ciphertexts[0]
        for ctxt in ciphertexts[1:]:
            result += ctxt
        return result

    def average_encrypted(self, ciphertexts: List['PyCtxt']) -> 'PyCtxt':
        """
        Homomorphically compute the average of ciphertexts.

        Note: For the CKKS scheme, division by a scalar is implemented by
        multiplying with its reciprocal.  This does not work for BFV which
        requires modular inverse and thus is not supported here.

        :param ciphertexts: list of ciphertexts.
        :return: ciphertext representing the average.
        """
        total = self.sum_encrypted(ciphertexts)
        divisor = len(ciphertexts)
        # Multiply by reciprocal (1/divisor) for CKKS; this leaves the scale unchanged.
        return total * (1.0 / divisor)

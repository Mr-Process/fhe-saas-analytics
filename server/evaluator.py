"""
Server-side evaluator for FHE-based SaaS analytics service.

This module receives serialized ciphertexts from clients, deserializes them
using a provided context, performs homomorphic computation on the encrypted
values, and returns serialized ciphertext results. It illustrates how to
structure server-side logic for privacy-preserving analytics.

The functions here are simple examples; a production system would need
additional functionality, such as secure key exchange, batching, more complex
analytics, and parameter tuning.  The evaluator must never have access to
the client's secret key.
"""

from typing import List
from server.evaluator_decorators import enforce_depth

try:
    from Pyfhel import Pyfhel, PyCtxt
except ImportError:
    Pyfhel = None  # type: ignore
    PyCtxt = None  # type: ignore

class FHEEvaluator:
    """
    Evaluator for performing encrypted computations. The evaluator requires
    access to the encryption context but never the secret key.  The context
    parameters and public keys must be provided by the client.
    """

    def __init__(self, context_params: dict) -> None:
        """
        Initialise the evaluator with encryption parameters provided by the client.

        :param context_params: dictionary containing contextGen parameters.
        """
        if Pyfhel is None:
            raise ImportError(
                "Pyfhel is required for FHEEvaluator. Install it via pip (e.g. pip install pyfhel)."
            )
        self.he = Pyfhel()
        # The context generation replicates the client's parameters.  This ensures
        # that ciphertexts created by the client can be processed on the server.
        self.he.contextGen(**context_params)
        # In a real implementation, the public, relinearization, and rotation
        # keys would be imported at this point using he.publicKey, he.relinKey
        # and he.rotateKey.  These keys are generated by the client and sent
        # along with the encrypted data.

    def max_circuit_depth(self) -> int:
        """
        Return the max multiplicative depth supported by the current context.
        Pyfhel stores CKKS chain in 'qi_sizes'. For BFV, an estimate is returned.
        """
        if hasattr(self.he, "qi_sizes"):
            return max(len(getattr(self.he, "qi_sizes", [])) - 1, 1)
        elif self.he.is_scheme("BFV"):
            return 2  # Integer opsâ€”barely support 1-2 mults
        else:
            return 1  # Default/fallback

    def check_circuit_depth(self, required_depth: int, analytic_name: str):
        max_depth = self.max_circuit_depth()
        if required_depth > max_depth:
            raise RuntimeError(
                f"'{analytic_name}' requires multiplicative depth {required_depth}, "
                f"but only {max_depth} is supported by current FHE context."
            )

    def deserialize_ciphertexts(self, data: List[bytes]) -> List['PyCtxt']:
        """
        Deserialize a list of ciphertext byte strings into Pyfhel ciphertexts.
        :param data: list of byte strings.
        :return: list of ciphertext objects.
        """
        return [self.he.ciphertext_from_bytes(b) for b in data]

    def serialize_ciphertexts(self, ciphertexts: List['PyCtxt']) -> List[bytes]:
        """Serialize ciphertexts into byte strings for returning to client."""
        return [ctxt.to_bytes() for ctxt in ciphertexts]

    @enforce_depth(1, "sum_encrypted")
    def sum_encrypted(self, ciphertexts: List['PyCtxt']) -> 'PyCtxt':
        """
        Homomorphically sum a list of ciphertexts.
        :param ciphertexts: list of ciphertext objects.
        :return: ciphertext representing the sum of all inputs.
        """
        if not ciphertexts:
            raise ValueError("ciphertexts list cannot be empty")
        result = ciphertexts[0]
        for ctxt in ciphertexts[1:]:
            result += ctxt
        return result

    @enforce_depth(2, "average_encrypted")
    def average_encrypted(self, ciphertexts: List['PyCtxt']) -> 'PyCtxt':
        """
        Homomorphically compute the average of ciphertexts.
        Note: For the CKKS scheme, division by a scalar is implemented by
        multiplying with its reciprocal.  This does not work for BFV which
        requires modular inverse and thus is not supported here.
        :param ciphertexts: list of ciphertexts.
        :return: ciphertext representing the average.
        """
        total = self.sum_encrypted(ciphertexts)
        divisor = len(ciphertexts)
        # Multiply by reciprocal (1/divisor) for CKKS; this leaves the scale unchanged.
        return total * (1.0 / divisor)

    @enforce_depth(1, "weighted_sum")
    def weighted_sum(self, ciphertexts: List['PyCtxt'], weights: List[float]) -> 'PyCtxt':
        """
        Homomorphically compute a weighted sum of ciphertexts.
        Each ciphertext is multiplied by a corresponding plaintext weight and
        the products are summed. This requires a homomorphic multiplication
        of ciphertext by a plaintext constant (supported for CKKS and BFV schemes).
        :param ciphertexts: list of ciphertext objects to be weighted.
        :param weights: list of plaintext weights (same length as ciphertexts).
        :return: ciphertext representing the weighted sum.
        """
        if len(ciphertexts) != len(weights):
            raise ValueError("ciphertexts and weights must be the same length")
        result = ciphertexts[0] * weights[0]
        for ctxt, w in zip(ciphertexts[1:], weights[1:]):
            result += ctxt * w
        return result

